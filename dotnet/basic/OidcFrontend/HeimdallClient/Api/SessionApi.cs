/*
 * Heimdall
 *
 * # Introduction    The Heimdall backchannel API is a [RESTful](https://wikipedia.org/wiki/Representational_state_transfer) API that allows you to do authorizations, manage sessions, do CRUD on various objects, etc.          
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using HeimdallClient.Client;
using HeimdallClient.Model;

namespace HeimdallClient.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISessionApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Append session data
        /// </summary>
        /// <remarks>
        /// Appends arbitrary data to an session. This can be useful in more complex authentication scenarios, where you have  a need to store data related to the end-users single sign-on session. An example use case of session data  is identity federation. When authenticating the user via a third party IdP, you might want to store data related  to the federation - an example could be storing the id token from the federated identity provider. The stored id  token could then be used as the &#x60;id_token_hint&#x60; in the case of a federated logout of the third party IdP.  Storing data in the session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionDataRequest"></param>
        /// <returns></returns>
        void AddDataToSession(SessionDataRequest sessionDataRequest);

        /// <summary>
        /// Append session data
        /// </summary>
        /// <remarks>
        /// Appends arbitrary data to an session. This can be useful in more complex authentication scenarios, where you have  a need to store data related to the end-users single sign-on session. An example use case of session data  is identity federation. When authenticating the user via a third party IdP, you might want to store data related  to the federation - an example could be storing the id token from the federated identity provider. The stored id  token could then be used as the &#x60;id_token_hint&#x60; in the case of a federated logout of the third party IdP.  Storing data in the session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionDataRequest"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddDataToSessionWithHttpInfo(SessionDataRequest sessionDataRequest);
        /// <summary>
        /// Get session
        /// </summary>
        /// <remarks>
        /// Retrieves the meta data associated to a single session.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Session identifier</param>
        /// <returns>SessionState</returns>
        SessionState GetSession(string sid);

        /// <summary>
        /// Get session
        /// </summary>
        /// <remarks>
        /// Retrieves the meta data associated to a single session.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Session identifier</param>
        /// <returns>ApiResponse of SessionState</returns>
        ApiResponse<SessionState> GetSessionWithHttpInfo(string sid);
        /// <summary>
        /// RP-initiated logout
        /// </summary>
        /// <remarks>
        /// Performs log out of an end-user in accordance with the _\&quot;OpenID Connect RP-Initiated Logout 1.0\&quot;_ specification.  This operation is usually the first step when creating a login page  at the OAuth 2.0 end session endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;final_response&#x60;, &#x60;logout_prompt&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutRequest"></param>
        /// <returns>LogoutResponse</returns>
        LogoutResponse RpInitiatedLogout(LogoutRequest logoutRequest);

        /// <summary>
        /// RP-initiated logout
        /// </summary>
        /// <remarks>
        /// Performs log out of an end-user in accordance with the _\&quot;OpenID Connect RP-Initiated Logout 1.0\&quot;_ specification.  This operation is usually the first step when creating a login page  at the OAuth 2.0 end session endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;final_response&#x60;, &#x60;logout_prompt&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutRequest"></param>
        /// <returns>ApiResponse of LogoutResponse</returns>
        ApiResponse<LogoutResponse> RpInitiatedLogoutWithHttpInfo(LogoutRequest logoutRequest);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISessionApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Append session data
        /// </summary>
        /// <remarks>
        /// Appends arbitrary data to an session. This can be useful in more complex authentication scenarios, where you have  a need to store data related to the end-users single sign-on session. An example use case of session data  is identity federation. When authenticating the user via a third party IdP, you might want to store data related  to the federation - an example could be storing the id token from the federated identity provider. The stored id  token could then be used as the &#x60;id_token_hint&#x60; in the case of a federated logout of the third party IdP.  Storing data in the session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddDataToSessionAsync(SessionDataRequest sessionDataRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Append session data
        /// </summary>
        /// <remarks>
        /// Appends arbitrary data to an session. This can be useful in more complex authentication scenarios, where you have  a need to store data related to the end-users single sign-on session. An example use case of session data  is identity federation. When authenticating the user via a third party IdP, you might want to store data related  to the federation - an example could be storing the id token from the federated identity provider. The stored id  token could then be used as the &#x60;id_token_hint&#x60; in the case of a federated logout of the third party IdP.  Storing data in the session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddDataToSessionWithHttpInfoAsync(SessionDataRequest sessionDataRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get session
        /// </summary>
        /// <remarks>
        /// Retrieves the meta data associated to a single session.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Session identifier</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SessionState</returns>
        System.Threading.Tasks.Task<SessionState> GetSessionAsync(string sid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get session
        /// </summary>
        /// <remarks>
        /// Retrieves the meta data associated to a single session.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Session identifier</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SessionState)</returns>
        System.Threading.Tasks.Task<ApiResponse<SessionState>> GetSessionWithHttpInfoAsync(string sid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// RP-initiated logout
        /// </summary>
        /// <remarks>
        /// Performs log out of an end-user in accordance with the _\&quot;OpenID Connect RP-Initiated Logout 1.0\&quot;_ specification.  This operation is usually the first step when creating a login page  at the OAuth 2.0 end session endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;final_response&#x60;, &#x60;logout_prompt&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LogoutResponse</returns>
        System.Threading.Tasks.Task<LogoutResponse> RpInitiatedLogoutAsync(LogoutRequest logoutRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// RP-initiated logout
        /// </summary>
        /// <remarks>
        /// Performs log out of an end-user in accordance with the _\&quot;OpenID Connect RP-Initiated Logout 1.0\&quot;_ specification.  This operation is usually the first step when creating a login page  at the OAuth 2.0 end session endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;final_response&#x60;, &#x60;logout_prompt&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LogoutResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<LogoutResponse>> RpInitiatedLogoutWithHttpInfoAsync(LogoutRequest logoutRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISessionApi : ISessionApiSync, ISessionApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class SessionApi : ISessionApi
    {
        private HeimdallClient.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="SessionApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SessionApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SessionApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SessionApi(string basePath)
        {
            this.Configuration = HeimdallClient.Client.Configuration.MergeConfigurations(
                HeimdallClient.Client.GlobalConfiguration.Instance,
                new HeimdallClient.Client.Configuration { BasePath = basePath }
            );
            this.Client = new HeimdallClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new HeimdallClient.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = HeimdallClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SessionApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public SessionApi(HeimdallClient.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = HeimdallClient.Client.Configuration.MergeConfigurations(
                HeimdallClient.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new HeimdallClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new HeimdallClient.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = HeimdallClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SessionApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public SessionApi(HeimdallClient.Client.ISynchronousClient client, HeimdallClient.Client.IAsynchronousClient asyncClient, HeimdallClient.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = HeimdallClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public HeimdallClient.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public HeimdallClient.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public HeimdallClient.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public HeimdallClient.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Append session data Appends arbitrary data to an session. This can be useful in more complex authentication scenarios, where you have  a need to store data related to the end-users single sign-on session. An example use case of session data  is identity federation. When authenticating the user via a third party IdP, you might want to store data related  to the federation - an example could be storing the id token from the federated identity provider. The stored id  token could then be used as the &#x60;id_token_hint&#x60; in the case of a federated logout of the third party IdP.  Storing data in the session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionDataRequest"></param>
        /// <returns></returns>
        public void AddDataToSession(SessionDataRequest sessionDataRequest)
        {
            AddDataToSessionWithHttpInfo(sessionDataRequest);
        }

        /// <summary>
        /// Append session data Appends arbitrary data to an session. This can be useful in more complex authentication scenarios, where you have  a need to store data related to the end-users single sign-on session. An example use case of session data  is identity federation. When authenticating the user via a third party IdP, you might want to store data related  to the federation - an example could be storing the id token from the federated identity provider. The stored id  token could then be used as the &#x60;id_token_hint&#x60; in the case of a federated logout of the third party IdP.  Storing data in the session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionDataRequest"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public HeimdallClient.Client.ApiResponse<Object> AddDataToSessionWithHttpInfo(SessionDataRequest sessionDataRequest)
        {
            // verify the required parameter 'sessionDataRequest' is set
            if (sessionDataRequest == null)
            {
                throw new HeimdallClient.Client.ApiException(400, "Missing required parameter 'sessionDataRequest' when calling SessionApi->AddDataToSession");
            }

            HeimdallClient.Client.RequestOptions localVarRequestOptions = new HeimdallClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = HeimdallClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HeimdallClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = sessionDataRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/session/data", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AddDataToSession", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Append session data Appends arbitrary data to an session. This can be useful in more complex authentication scenarios, where you have  a need to store data related to the end-users single sign-on session. An example use case of session data  is identity federation. When authenticating the user via a third party IdP, you might want to store data related  to the federation - an example could be storing the id token from the federated identity provider. The stored id  token could then be used as the &#x60;id_token_hint&#x60; in the case of a federated logout of the third party IdP.  Storing data in the session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddDataToSessionAsync(SessionDataRequest sessionDataRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await AddDataToSessionWithHttpInfoAsync(sessionDataRequest, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Append session data Appends arbitrary data to an session. This can be useful in more complex authentication scenarios, where you have  a need to store data related to the end-users single sign-on session. An example use case of session data  is identity federation. When authenticating the user via a third party IdP, you might want to store data related  to the federation - an example could be storing the id token from the federated identity provider. The stored id  token could then be used as the &#x60;id_token_hint&#x60; in the case of a federated logout of the third party IdP.  Storing data in the session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<HeimdallClient.Client.ApiResponse<Object>> AddDataToSessionWithHttpInfoAsync(SessionDataRequest sessionDataRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'sessionDataRequest' is set
            if (sessionDataRequest == null)
            {
                throw new HeimdallClient.Client.ApiException(400, "Missing required parameter 'sessionDataRequest' when calling SessionApi->AddDataToSession");
            }


            HeimdallClient.Client.RequestOptions localVarRequestOptions = new HeimdallClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = HeimdallClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HeimdallClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = sessionDataRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/session/data", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AddDataToSession", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get session Retrieves the meta data associated to a single session.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Session identifier</param>
        /// <returns>SessionState</returns>
        public SessionState GetSession(string sid)
        {
            HeimdallClient.Client.ApiResponse<SessionState> localVarResponse = GetSessionWithHttpInfo(sid);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get session Retrieves the meta data associated to a single session.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Session identifier</param>
        /// <returns>ApiResponse of SessionState</returns>
        public HeimdallClient.Client.ApiResponse<SessionState> GetSessionWithHttpInfo(string sid)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
            {
                throw new HeimdallClient.Client.ApiException(400, "Missing required parameter 'sid' when calling SessionApi->GetSession");
            }

            HeimdallClient.Client.RequestOptions localVarRequestOptions = new HeimdallClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = HeimdallClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HeimdallClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("sid", HeimdallClient.Client.ClientUtils.ParameterToString(sid)); // path parameter

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SessionState>("/session/{sid}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSession", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get session Retrieves the meta data associated to a single session.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Session identifier</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SessionState</returns>
        public async System.Threading.Tasks.Task<SessionState> GetSessionAsync(string sid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HeimdallClient.Client.ApiResponse<SessionState> localVarResponse = await GetSessionWithHttpInfoAsync(sid, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get session Retrieves the meta data associated to a single session.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Session identifier</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SessionState)</returns>
        public async System.Threading.Tasks.Task<HeimdallClient.Client.ApiResponse<SessionState>> GetSessionWithHttpInfoAsync(string sid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
            {
                throw new HeimdallClient.Client.ApiException(400, "Missing required parameter 'sid' when calling SessionApi->GetSession");
            }


            HeimdallClient.Client.RequestOptions localVarRequestOptions = new HeimdallClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = HeimdallClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HeimdallClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("sid", HeimdallClient.Client.ClientUtils.ParameterToString(sid)); // path parameter

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<SessionState>("/session/{sid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSession", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// RP-initiated logout Performs log out of an end-user in accordance with the _\&quot;OpenID Connect RP-Initiated Logout 1.0\&quot;_ specification.  This operation is usually the first step when creating a login page  at the OAuth 2.0 end session endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;final_response&#x60;, &#x60;logout_prompt&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutRequest"></param>
        /// <returns>LogoutResponse</returns>
        public LogoutResponse RpInitiatedLogout(LogoutRequest logoutRequest)
        {
            HeimdallClient.Client.ApiResponse<LogoutResponse> localVarResponse = RpInitiatedLogoutWithHttpInfo(logoutRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// RP-initiated logout Performs log out of an end-user in accordance with the _\&quot;OpenID Connect RP-Initiated Logout 1.0\&quot;_ specification.  This operation is usually the first step when creating a login page  at the OAuth 2.0 end session endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;final_response&#x60;, &#x60;logout_prompt&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutRequest"></param>
        /// <returns>ApiResponse of LogoutResponse</returns>
        public HeimdallClient.Client.ApiResponse<LogoutResponse> RpInitiatedLogoutWithHttpInfo(LogoutRequest logoutRequest)
        {
            // verify the required parameter 'logoutRequest' is set
            if (logoutRequest == null)
            {
                throw new HeimdallClient.Client.ApiException(400, "Missing required parameter 'logoutRequest' when calling SessionApi->RpInitiatedLogout");
            }

            HeimdallClient.Client.RequestOptions localVarRequestOptions = new HeimdallClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = HeimdallClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HeimdallClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = logoutRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<LogoutResponse>("/session/rp_initiated_logout", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RpInitiatedLogout", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// RP-initiated logout Performs log out of an end-user in accordance with the _\&quot;OpenID Connect RP-Initiated Logout 1.0\&quot;_ specification.  This operation is usually the first step when creating a login page  at the OAuth 2.0 end session endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;final_response&#x60;, &#x60;logout_prompt&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LogoutResponse</returns>
        public async System.Threading.Tasks.Task<LogoutResponse> RpInitiatedLogoutAsync(LogoutRequest logoutRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HeimdallClient.Client.ApiResponse<LogoutResponse> localVarResponse = await RpInitiatedLogoutWithHttpInfoAsync(logoutRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// RP-initiated logout Performs log out of an end-user in accordance with the _\&quot;OpenID Connect RP-Initiated Logout 1.0\&quot;_ specification.  This operation is usually the first step when creating a login page  at the OAuth 2.0 end session endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;final_response&#x60;, &#x60;logout_prompt&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="HeimdallClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LogoutResponse)</returns>
        public async System.Threading.Tasks.Task<HeimdallClient.Client.ApiResponse<LogoutResponse>> RpInitiatedLogoutWithHttpInfoAsync(LogoutRequest logoutRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'logoutRequest' is set
            if (logoutRequest == null)
            {
                throw new HeimdallClient.Client.ApiException(400, "Missing required parameter 'logoutRequest' when calling SessionApi->RpInitiatedLogout");
            }


            HeimdallClient.Client.RequestOptions localVarRequestOptions = new HeimdallClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = HeimdallClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HeimdallClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = logoutRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<LogoutResponse>("/session/rp_initiated_logout", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RpInitiatedLogout", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
