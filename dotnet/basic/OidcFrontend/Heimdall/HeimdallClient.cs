// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Heimdall
{
    /// <summary> The Heimdall service client. </summary>
    public partial class HeimdallClient
    {
        private const string AuthorizationHeader = "X-API-KEY";
        private readonly AzureKeyCredential _keyCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of HeimdallClient for mocking. </summary>
        protected HeimdallClient()
        {
        }

        /// <summary> Initializes a new instance of HeimdallClient. </summary>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="credential"/> is null. </exception>
        public HeimdallClient(AzureKeyCredential credential) : this(credential, new Uri(""), new HeimdallClientOptions())
        {
        }

        /// <summary> Initializes a new instance of HeimdallClient. </summary>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        public HeimdallClient(AzureKeyCredential credential, Uri endpoint, HeimdallClientOptions options)
        {
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new HeimdallClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _keyCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new AzureKeyCredentialPolicy(_keyCredential, AuthorizationHeader) }, new ResponseClassifier());
            _endpoint = endpoint;
        }

        /// <summary>
        /// Peeks the query payload of an authorization request without starting an authorization session, 
        /// which can be useful in several scenarios. 
        ///             
        /// It allows you to determine if the authorization request is valid, and 
        /// if it is valid it allows you to decode the query payload, which you can use to control custom business logic.
        /// An example could be if your implementation allows federation with multiple identity providers, but perhaps not all 
        /// federation providers are valid for all clients. Using the peek operation you can peek the client id, and decide 
        /// which single sign-on session cookie to use for the `/authz/authorize` operation.
        ///             
        /// Another example where the peek operation can be particularly useful, is for pushed authorization requests (PAR)
        /// allowing you to peek the stored content of the request, without having to consume the PAR Uri.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AuthorizePeekRequest</c>:
        /// <code>{
        ///   query: string, # Required. The URI query string received at the OAuth 2.0/OIDC authorization endpoint. This must be the raw query string (Heimdall will do the decoding).
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AuthPeekResponse</c>:
        /// <code>{
        ///   request: Dictionary&lt;string, string&gt;, # Optional. Dictionary of &lt;string&gt;
        ///   is_valid: boolean, # Optional.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AuthorizePeekAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.AuthorizePeek");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAuthorizePeekRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Peeks the query payload of an authorization request without starting an authorization session, 
        /// which can be useful in several scenarios. 
        ///             
        /// It allows you to determine if the authorization request is valid, and 
        /// if it is valid it allows you to decode the query payload, which you can use to control custom business logic.
        /// An example could be if your implementation allows federation with multiple identity providers, but perhaps not all 
        /// federation providers are valid for all clients. Using the peek operation you can peek the client id, and decide 
        /// which single sign-on session cookie to use for the `/authz/authorize` operation.
        ///             
        /// Another example where the peek operation can be particularly useful, is for pushed authorization requests (PAR)
        /// allowing you to peek the stored content of the request, without having to consume the PAR Uri.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AuthorizePeekRequest</c>:
        /// <code>{
        ///   query: string, # Required. The URI query string received at the OAuth 2.0/OIDC authorization endpoint. This must be the raw query string (Heimdall will do the decoding).
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AuthPeekResponse</c>:
        /// <code>{
        ///   request: Dictionary&lt;string, string&gt;, # Optional. Dictionary of &lt;string&gt;
        ///   is_valid: boolean, # Optional.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response AuthorizePeek(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.AuthorizePeek");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAuthorizePeekRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        ///  Starts a new authorization session with Heimdall. This is usually the first step when creating a login page
        /// at the OAuth 2.0 authorization endpoint. This operation expects the original query string as well as a session cookie
        /// if one exists. The operation will always return exactly one of the following JSON objects (all but one will have `null` values):
        /// `auth`, `final_response`, `consent`, `error`.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AuthorizeRequest</c>:
        /// <code>{
        ///   query: string, # Required. The URI query string received at the OAuth 2.0/OIDC authorization endpoint. This must be the raw query string (Heimdall will do the decoding).
        ///   session: string, # Optional. The session identifier (if any), which has been stored in a browser HTTP only cookie. This is used to identify  the users single sign-on session.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AuthResponse</c>:
        /// <code>{
        ///   auth: {
        ///     auth_sid: string, # Required. Authorization session identifier of the created authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     request: Dictionary&lt;string, string&gt;, # Required. Request parameters of the authorization request decoded as JSON. If the authorization request
        /// is a Pushed Access Request (PAR), the request field will contain the value of the original pushed access request 
        /// as it has been stored in the backend (this allows you to use the `request` field for both PAR and non-PAR requests).
        ///   }, # Optional. Indicating an authenthication prompt is required for the end user. The response includes the `client_id` of the 
        /// requesting OAuth 2.0/OIDC client, the `auth_sid` which is the newly created authorization session identifier, and the
        ///   final_response: {
        ///     uri: string, # Required. The URI to which the user agent should be redirected.
        ///     session: string, # Optional. Indicates the single sign-on session identifier, that should be stored in the user-agents cookie store as a HTTP-only cookie.
        /// This value can be null if the authorization was not successfull for instance.
        ///     mode: &quot;Query&quot; | &quot;FormPost&quot; | &quot;JwtQuery&quot; | &quot;JwtPost&quot; | &quot;Fragment&quot; | &quot;Unknown&quot;, # Required.
        ///     parameters: Dictionary&lt;string, string&gt;, # Required. Response parameters that should be included in the redirect (how these are encoded/serialized depends on the value of the `mode` field).
        ///   }, # Optional. Indicates a final response that redirects to the client application. The frontend is required to redirect the user-agent (the browser)
        /// to the client application with the specified authenthication response. A final response type implicitely terminates the authorization session.
        ///   consent: {
        ///     auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     sub: string, # Required. The user identifier for the authenticated end-user
        ///     requested_scopes: [string], # Required. List of scopes that the client application is requesting
        ///     requested_claims: [string], # Required. List of claims that the client application is requesting
        ///   }, # Optional. Indicating that the user is authenthicated (for instance via a single sign-on cookie, 
        /// or following an authorize accept operation), but consent is required from 
        /// the end user. The frontend should obtain the users consent for the specified scopes and claims.
        /// **NOTE:** This response type is still
        /// being designed, and will be updated in future versions of Hemdall.
        ///   error: {
        ///     error: string, # Required. Error to display to the end-user.
        ///     status_code: number, # Required. HTTP status code that the frontend should use in the response.
        ///   }, # Optional. Indicates that the authorization request is invalid. The frontend must display an error to the end-user an must
        /// not redirect back to the client application.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AuthorizeAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.Authorize");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAuthorizeRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        ///  Starts a new authorization session with Heimdall. This is usually the first step when creating a login page
        /// at the OAuth 2.0 authorization endpoint. This operation expects the original query string as well as a session cookie
        /// if one exists. The operation will always return exactly one of the following JSON objects (all but one will have `null` values):
        /// `auth`, `final_response`, `consent`, `error`.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AuthorizeRequest</c>:
        /// <code>{
        ///   query: string, # Required. The URI query string received at the OAuth 2.0/OIDC authorization endpoint. This must be the raw query string (Heimdall will do the decoding).
        ///   session: string, # Optional. The session identifier (if any), which has been stored in a browser HTTP only cookie. This is used to identify  the users single sign-on session.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AuthResponse</c>:
        /// <code>{
        ///   auth: {
        ///     auth_sid: string, # Required. Authorization session identifier of the created authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     request: Dictionary&lt;string, string&gt;, # Required. Request parameters of the authorization request decoded as JSON. If the authorization request
        /// is a Pushed Access Request (PAR), the request field will contain the value of the original pushed access request 
        /// as it has been stored in the backend (this allows you to use the `request` field for both PAR and non-PAR requests).
        ///   }, # Optional. Indicating an authenthication prompt is required for the end user. The response includes the `client_id` of the 
        /// requesting OAuth 2.0/OIDC client, the `auth_sid` which is the newly created authorization session identifier, and the
        ///   final_response: {
        ///     uri: string, # Required. The URI to which the user agent should be redirected.
        ///     session: string, # Optional. Indicates the single sign-on session identifier, that should be stored in the user-agents cookie store as a HTTP-only cookie.
        /// This value can be null if the authorization was not successfull for instance.
        ///     mode: &quot;Query&quot; | &quot;FormPost&quot; | &quot;JwtQuery&quot; | &quot;JwtPost&quot; | &quot;Fragment&quot; | &quot;Unknown&quot;, # Required.
        ///     parameters: Dictionary&lt;string, string&gt;, # Required. Response parameters that should be included in the redirect (how these are encoded/serialized depends on the value of the `mode` field).
        ///   }, # Optional. Indicates a final response that redirects to the client application. The frontend is required to redirect the user-agent (the browser)
        /// to the client application with the specified authenthication response. A final response type implicitely terminates the authorization session.
        ///   consent: {
        ///     auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     sub: string, # Required. The user identifier for the authenticated end-user
        ///     requested_scopes: [string], # Required. List of scopes that the client application is requesting
        ///     requested_claims: [string], # Required. List of claims that the client application is requesting
        ///   }, # Optional. Indicating that the user is authenthicated (for instance via a single sign-on cookie, 
        /// or following an authorize accept operation), but consent is required from 
        /// the end user. The frontend should obtain the users consent for the specified scopes and claims.
        /// **NOTE:** This response type is still
        /// being designed, and will be updated in future versions of Hemdall.
        ///   error: {
        ///     error: string, # Required. Error to display to the end-user.
        ///     status_code: number, # Required. HTTP status code that the frontend should use in the response.
        ///   }, # Optional. Indicates that the authorization request is invalid. The frontend must display an error to the end-user an must
        /// not redirect back to the client application.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Authorize(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.Authorize");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAuthorizeRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Finalizes an authorization session with Heimdall. This is the final step carried out before the user agent will be redirected
        /// to the client application. The accept consent operation allow you to specify which claims and scopes the user consented to.
        /// Depending on your needs, you can also automatically accept claims without having asked the user for consent (this can be common
        /// in some type of enterprise applications for instance). The accept consent also provides an opportunity to enriched the generated
        /// token(s) with additional claims. The operation will always return exactly one of the following JSON objects (all but one will have `null` values):
        /// `auth`, `final_response`, `consent`, `error`.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ConsentAcceptRequest</c>:
        /// <code>{
        ///   auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///   claims: [string], # Required. List of claims that the end-user accepted
        ///   scopes: [string], # Required. List of scopes that the end-user accepted
        ///   additional_claims: {
        ///     access_token: Dictionary&lt;string, object&gt;, # Optional. Claims to be included in the generated access token (if generated - depends on the grant type).
        ///     id_token: Dictionary&lt;string, object&gt;, # Optional. Claims to be included in the generated id token (if generated - depends on the grant type).
        ///   }, # Optional. Additional claims you to include in the generated token(s)
        ///   callback_claims_source: boolean, # Optional. Indicate if claims should be refreshed when the user exchanges a refresh token for a fresh token.
        /// If set to `true`, the configured `callback_claims_source` endpoint will be invoked when a refresh token 
        /// is exchanged, giving you an opportunity to refresh the claims that are included in the generated token(s).
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AuthResponse</c>:
        /// <code>{
        ///   auth: {
        ///     auth_sid: string, # Required. Authorization session identifier of the created authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     request: Dictionary&lt;string, string&gt;, # Required. Request parameters of the authorization request decoded as JSON. If the authorization request
        /// is a Pushed Access Request (PAR), the request field will contain the value of the original pushed access request 
        /// as it has been stored in the backend (this allows you to use the `request` field for both PAR and non-PAR requests).
        ///   }, # Optional. Indicating an authenthication prompt is required for the end user. The response includes the `client_id` of the 
        /// requesting OAuth 2.0/OIDC client, the `auth_sid` which is the newly created authorization session identifier, and the
        ///   final_response: {
        ///     uri: string, # Required. The URI to which the user agent should be redirected.
        ///     session: string, # Optional. Indicates the single sign-on session identifier, that should be stored in the user-agents cookie store as a HTTP-only cookie.
        /// This value can be null if the authorization was not successfull for instance.
        ///     mode: &quot;Query&quot; | &quot;FormPost&quot; | &quot;JwtQuery&quot; | &quot;JwtPost&quot; | &quot;Fragment&quot; | &quot;Unknown&quot;, # Required.
        ///     parameters: Dictionary&lt;string, string&gt;, # Required. Response parameters that should be included in the redirect (how these are encoded/serialized depends on the value of the `mode` field).
        ///   }, # Optional. Indicates a final response that redirects to the client application. The frontend is required to redirect the user-agent (the browser)
        /// to the client application with the specified authenthication response. A final response type implicitely terminates the authorization session.
        ///   consent: {
        ///     auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     sub: string, # Required. The user identifier for the authenticated end-user
        ///     requested_scopes: [string], # Required. List of scopes that the client application is requesting
        ///     requested_claims: [string], # Required. List of claims that the client application is requesting
        ///   }, # Optional. Indicating that the user is authenthicated (for instance via a single sign-on cookie, 
        /// or following an authorize accept operation), but consent is required from 
        /// the end user. The frontend should obtain the users consent for the specified scopes and claims.
        /// **NOTE:** This response type is still
        /// being designed, and will be updated in future versions of Hemdall.
        ///   error: {
        ///     error: string, # Required. Error to display to the end-user.
        ///     status_code: number, # Required. HTTP status code that the frontend should use in the response.
        ///   }, # Optional. Indicates that the authorization request is invalid. The frontend must display an error to the end-user an must
        /// not redirect back to the client application.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> ConsentAcceptAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.ConsentAccept");
            scope.Start();
            try
            {
                using HttpMessage message = CreateConsentAcceptRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Finalizes an authorization session with Heimdall. This is the final step carried out before the user agent will be redirected
        /// to the client application. The accept consent operation allow you to specify which claims and scopes the user consented to.
        /// Depending on your needs, you can also automatically accept claims without having asked the user for consent (this can be common
        /// in some type of enterprise applications for instance). The accept consent also provides an opportunity to enriched the generated
        /// token(s) with additional claims. The operation will always return exactly one of the following JSON objects (all but one will have `null` values):
        /// `auth`, `final_response`, `consent`, `error`.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ConsentAcceptRequest</c>:
        /// <code>{
        ///   auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///   claims: [string], # Required. List of claims that the end-user accepted
        ///   scopes: [string], # Required. List of scopes that the end-user accepted
        ///   additional_claims: {
        ///     access_token: Dictionary&lt;string, object&gt;, # Optional. Claims to be included in the generated access token (if generated - depends on the grant type).
        ///     id_token: Dictionary&lt;string, object&gt;, # Optional. Claims to be included in the generated id token (if generated - depends on the grant type).
        ///   }, # Optional. Additional claims you to include in the generated token(s)
        ///   callback_claims_source: boolean, # Optional. Indicate if claims should be refreshed when the user exchanges a refresh token for a fresh token.
        /// If set to `true`, the configured `callback_claims_source` endpoint will be invoked when a refresh token 
        /// is exchanged, giving you an opportunity to refresh the claims that are included in the generated token(s).
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AuthResponse</c>:
        /// <code>{
        ///   auth: {
        ///     auth_sid: string, # Required. Authorization session identifier of the created authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     request: Dictionary&lt;string, string&gt;, # Required. Request parameters of the authorization request decoded as JSON. If the authorization request
        /// is a Pushed Access Request (PAR), the request field will contain the value of the original pushed access request 
        /// as it has been stored in the backend (this allows you to use the `request` field for both PAR and non-PAR requests).
        ///   }, # Optional. Indicating an authenthication prompt is required for the end user. The response includes the `client_id` of the 
        /// requesting OAuth 2.0/OIDC client, the `auth_sid` which is the newly created authorization session identifier, and the
        ///   final_response: {
        ///     uri: string, # Required. The URI to which the user agent should be redirected.
        ///     session: string, # Optional. Indicates the single sign-on session identifier, that should be stored in the user-agents cookie store as a HTTP-only cookie.
        /// This value can be null if the authorization was not successfull for instance.
        ///     mode: &quot;Query&quot; | &quot;FormPost&quot; | &quot;JwtQuery&quot; | &quot;JwtPost&quot; | &quot;Fragment&quot; | &quot;Unknown&quot;, # Required.
        ///     parameters: Dictionary&lt;string, string&gt;, # Required. Response parameters that should be included in the redirect (how these are encoded/serialized depends on the value of the `mode` field).
        ///   }, # Optional. Indicates a final response that redirects to the client application. The frontend is required to redirect the user-agent (the browser)
        /// to the client application with the specified authenthication response. A final response type implicitely terminates the authorization session.
        ///   consent: {
        ///     auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     sub: string, # Required. The user identifier for the authenticated end-user
        ///     requested_scopes: [string], # Required. List of scopes that the client application is requesting
        ///     requested_claims: [string], # Required. List of claims that the client application is requesting
        ///   }, # Optional. Indicating that the user is authenthicated (for instance via a single sign-on cookie, 
        /// or following an authorize accept operation), but consent is required from 
        /// the end user. The frontend should obtain the users consent for the specified scopes and claims.
        /// **NOTE:** This response type is still
        /// being designed, and will be updated in future versions of Hemdall.
        ///   error: {
        ///     error: string, # Required. Error to display to the end-user.
        ///     status_code: number, # Required. HTTP status code that the frontend should use in the response.
        ///   }, # Optional. Indicates that the authorization request is invalid. The frontend must display an error to the end-user an must
        /// not redirect back to the client application.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response ConsentAccept(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.ConsentAccept");
            scope.Start();
            try
            {
                using HttpMessage message = CreateConsentAcceptRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Registers an end-user as having been authorized. Registers the identity of the authenthicated user in the authorization session.
        /// This is called after the user has been authenthicated by whatever mechanisms used by your frontend to authenthicate 
        /// the end-user. The operation will always return exactly one of the following JSON objects (all but one will have `null` values):
        /// `auth`, `final_response`, `consent`, `error`.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AuthorizeAcceptRequest</c>:
        /// <code>{
        ///   auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///   sub: string, # Required. The identifier for the end-user (sub)
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AuthResponse</c>:
        /// <code>{
        ///   auth: {
        ///     auth_sid: string, # Required. Authorization session identifier of the created authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     request: Dictionary&lt;string, string&gt;, # Required. Request parameters of the authorization request decoded as JSON. If the authorization request
        /// is a Pushed Access Request (PAR), the request field will contain the value of the original pushed access request 
        /// as it has been stored in the backend (this allows you to use the `request` field for both PAR and non-PAR requests).
        ///   }, # Optional. Indicating an authenthication prompt is required for the end user. The response includes the `client_id` of the 
        /// requesting OAuth 2.0/OIDC client, the `auth_sid` which is the newly created authorization session identifier, and the
        ///   final_response: {
        ///     uri: string, # Required. The URI to which the user agent should be redirected.
        ///     session: string, # Optional. Indicates the single sign-on session identifier, that should be stored in the user-agents cookie store as a HTTP-only cookie.
        /// This value can be null if the authorization was not successfull for instance.
        ///     mode: &quot;Query&quot; | &quot;FormPost&quot; | &quot;JwtQuery&quot; | &quot;JwtPost&quot; | &quot;Fragment&quot; | &quot;Unknown&quot;, # Required.
        ///     parameters: Dictionary&lt;string, string&gt;, # Required. Response parameters that should be included in the redirect (how these are encoded/serialized depends on the value of the `mode` field).
        ///   }, # Optional. Indicates a final response that redirects to the client application. The frontend is required to redirect the user-agent (the browser)
        /// to the client application with the specified authenthication response. A final response type implicitely terminates the authorization session.
        ///   consent: {
        ///     auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     sub: string, # Required. The user identifier for the authenticated end-user
        ///     requested_scopes: [string], # Required. List of scopes that the client application is requesting
        ///     requested_claims: [string], # Required. List of claims that the client application is requesting
        ///   }, # Optional. Indicating that the user is authenthicated (for instance via a single sign-on cookie, 
        /// or following an authorize accept operation), but consent is required from 
        /// the end user. The frontend should obtain the users consent for the specified scopes and claims.
        /// **NOTE:** This response type is still
        /// being designed, and will be updated in future versions of Hemdall.
        ///   error: {
        ///     error: string, # Required. Error to display to the end-user.
        ///     status_code: number, # Required. HTTP status code that the frontend should use in the response.
        ///   }, # Optional. Indicates that the authorization request is invalid. The frontend must display an error to the end-user an must
        /// not redirect back to the client application.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AuthorizeAcceptAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.AuthorizeAccept");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAuthorizeAcceptRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Registers an end-user as having been authorized. Registers the identity of the authenthicated user in the authorization session.
        /// This is called after the user has been authenthicated by whatever mechanisms used by your frontend to authenthicate 
        /// the end-user. The operation will always return exactly one of the following JSON objects (all but one will have `null` values):
        /// `auth`, `final_response`, `consent`, `error`.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AuthorizeAcceptRequest</c>:
        /// <code>{
        ///   auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///   sub: string, # Required. The identifier for the end-user (sub)
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AuthResponse</c>:
        /// <code>{
        ///   auth: {
        ///     auth_sid: string, # Required. Authorization session identifier of the created authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     request: Dictionary&lt;string, string&gt;, # Required. Request parameters of the authorization request decoded as JSON. If the authorization request
        /// is a Pushed Access Request (PAR), the request field will contain the value of the original pushed access request 
        /// as it has been stored in the backend (this allows you to use the `request` field for both PAR and non-PAR requests).
        ///   }, # Optional. Indicating an authenthication prompt is required for the end user. The response includes the `client_id` of the 
        /// requesting OAuth 2.0/OIDC client, the `auth_sid` which is the newly created authorization session identifier, and the
        ///   final_response: {
        ///     uri: string, # Required. The URI to which the user agent should be redirected.
        ///     session: string, # Optional. Indicates the single sign-on session identifier, that should be stored in the user-agents cookie store as a HTTP-only cookie.
        /// This value can be null if the authorization was not successfull for instance.
        ///     mode: &quot;Query&quot; | &quot;FormPost&quot; | &quot;JwtQuery&quot; | &quot;JwtPost&quot; | &quot;Fragment&quot; | &quot;Unknown&quot;, # Required.
        ///     parameters: Dictionary&lt;string, string&gt;, # Required. Response parameters that should be included in the redirect (how these are encoded/serialized depends on the value of the `mode` field).
        ///   }, # Optional. Indicates a final response that redirects to the client application. The frontend is required to redirect the user-agent (the browser)
        /// to the client application with the specified authenthication response. A final response type implicitely terminates the authorization session.
        ///   consent: {
        ///     auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///     client_id: string, # Required. Client id of the OAuth 2.0/OIDC client that initiated the authorization request.
        ///     sub: string, # Required. The user identifier for the authenticated end-user
        ///     requested_scopes: [string], # Required. List of scopes that the client application is requesting
        ///     requested_claims: [string], # Required. List of claims that the client application is requesting
        ///   }, # Optional. Indicating that the user is authenthicated (for instance via a single sign-on cookie, 
        /// or following an authorize accept operation), but consent is required from 
        /// the end user. The frontend should obtain the users consent for the specified scopes and claims.
        /// **NOTE:** This response type is still
        /// being designed, and will be updated in future versions of Hemdall.
        ///   error: {
        ///     error: string, # Required. Error to display to the end-user.
        ///     status_code: number, # Required. HTTP status code that the frontend should use in the response.
        ///   }, # Optional. Indicates that the authorization request is invalid. The frontend must display an error to the end-user an must
        /// not redirect back to the client application.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response AuthorizeAccept(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.AuthorizeAccept");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAuthorizeAcceptRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Appends arbitrary data to an authorization session. This can be useful in more complex authentication scenarios.
        /// For instance, if you require multi-factor authentication, and want to store the challenge that you send to 
        /// end-user via some other communication channel (such as email, SMS, etc). Another example is if you authenticate
        /// users using identity federation with another OIDC provider. If your request to the third party IdP includes a nonce
        /// you can store this in the authorization sessions data store. 
        /// Storing data in the authorization session allows your frontend to be stateless, as you do not need to handle distributed
        /// persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AuthorizeDataRequest</c>:
        /// <code>{
        ///   auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///   data: Dictionary&lt;string, object&gt;, # Required. Arbitrary data to append to the authorization session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AuthorizeDataAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.AuthorizeData");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAuthorizeDataRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Appends arbitrary data to an authorization session. This can be useful in more complex authentication scenarios.
        /// For instance, if you require multi-factor authentication, and want to store the challenge that you send to 
        /// end-user via some other communication channel (such as email, SMS, etc). Another example is if you authenticate
        /// users using identity federation with another OIDC provider. If your request to the third party IdP includes a nonce
        /// you can store this in the authorization sessions data store. 
        /// Storing data in the authorization session allows your frontend to be stateless, as you do not need to handle distributed
        /// persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AuthorizeDataRequest</c>:
        /// <code>{
        ///   auth_sid: string, # Required. Authorization session identifier of the ongoing authorization session.
        ///   data: Dictionary&lt;string, object&gt;, # Required. Arbitrary data to append to the authorization session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response AuthorizeData(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.AuthorizeData");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAuthorizeDataRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves optional arbitrary data stored in the authorization session. </summary>
        /// <param name="authSid"> Authorization session identifier of the ongoing authorization session. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="authSid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="authSid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AuthSessionData</c>:
        /// <code>{
        ///   json_data: Dictionary&lt;string, object&gt;, # Optional. Arbitrary key-value pairs of optional data stored in the authorization session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AuthorizeDataGetAsync(string authSid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(authSid, nameof(authSid));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.AuthorizeDataGet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAuthorizeDataGetRequest(authSid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves optional arbitrary data stored in the authorization session. </summary>
        /// <param name="authSid"> Authorization session identifier of the ongoing authorization session. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="authSid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="authSid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AuthSessionData</c>:
        /// <code>{
        ///   json_data: Dictionary&lt;string, object&gt;, # Optional. Arbitrary key-value pairs of optional data stored in the authorization session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response AuthorizeDataGet(string authSid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(authSid, nameof(authSid));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.AuthorizeDataGet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAuthorizeDataGetRequest(authSid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to save a new claim that can be requested by client applications. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>IndividualClaim</c>:
        /// <code>{
        ///   name: string, # Required. Name of claim (used in tokens for instance).
        ///   consent_label: string, # Optional. Label to display to end-users when asking for consent (human readable text).
        ///   requires_consent: boolean, # Optional. Should end-users be prompted for consent if a client application requests this claim.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> SaveIndividualClaimAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.SaveIndividualClaim");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSaveIndividualClaimRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to save a new claim that can be requested by client applications. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>IndividualClaim</c>:
        /// <code>{
        ///   name: string, # Required. Name of claim (used in tokens for instance).
        ///   consent_label: string, # Optional. Label to display to end-users when asking for consent (human readable text).
        ///   requires_consent: boolean, # Optional. Should end-users be prompted for consent if a client application requests this claim.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response SaveIndividualClaim(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.SaveIndividualClaim");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSaveIndividualClaimRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to delete a claim. </summary>
        /// <param name="claim"> Name of claim to delete. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="claim"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="claim"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> ClaimDeleteAsync(string claim, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(claim, nameof(claim));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.ClaimDelete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateClaimDeleteRequest(claim, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to delete a claim. </summary>
        /// <param name="claim"> Name of claim to delete. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="claim"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="claim"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response ClaimDelete(string claim, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(claim, nameof(claim));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.ClaimDelete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateClaimDeleteRequest(claim, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to read all claims that can be requested by client applications. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArrayOfIndividualClaim</c>:
        /// <code>{
        ///   name: string, # Required. Name of claim (used in tokens for instance).
        ///   consent_label: string, # Optional. Label to display to end-users when asking for consent (human readable text).
        ///   requires_consent: boolean, # Optional. Should end-users be prompted for consent if a client application requests this claim.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> IndividualClaimsAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.IndividualClaims");
            scope.Start();
            try
            {
                using HttpMessage message = CreateIndividualClaimsRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to read all claims that can be requested by client applications. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArrayOfIndividualClaim</c>:
        /// <code>{
        ///   name: string, # Required. Name of claim (used in tokens for instance).
        ///   consent_label: string, # Optional. Label to display to end-users when asking for consent (human readable text).
        ///   requires_consent: boolean, # Optional. Should end-users be prompted for consent if a client application requests this claim.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response IndividualClaims(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.IndividualClaims");
            scope.Start();
            try
            {
                using HttpMessage message = CreateIndividualClaimsRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to save an OAuth2/OIDC client. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>Client</c>:
        /// <code>{
        ///   client_id: string, # Required. OIDC client id
        ///   return_uris: [string], # Required. List of redirection URIs that are allowed to utilized at the authorization endpoint.
        ///   post_logout_redirect_uris: [string], # Required. List of redirection URIs that end-user&apos;s User Agent can be redirected to after a logout has been performed
        /// at the end session endpoint.
        ///   client_secrets: [string], # Required. List of client secrets for a confidential clients.
        ///   client_certificate: string, # Optional. List of client certificate for a confidential clients. Certificates are specified in the PEM format.
        ///   back_channel_logout_uri: string, # Optional. Back-channel logout URI to be used when performing back-channel logouts according to the
        /// _&quot;OpenID Connect Back-Channel Logout 1.0&quot;_ specification.
        ///   requires_jwt_assertion: boolean, # Optional. Flag indicating if this client requires the use of JWT assertions
        ///   client_private_keys_jwt: [
        ///     {
        ///       kid: string, # Required. Key ID for the key.
        ///       pem_public_key: string, # Required. Public key specified in the PEM format.
        ///     }
        ///   ], # Optional. List of public keys, to be used for JWT assertions for confidential clients.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateClientAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.CreateClient");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateClientRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to save an OAuth2/OIDC client. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>Client</c>:
        /// <code>{
        ///   client_id: string, # Required. OIDC client id
        ///   return_uris: [string], # Required. List of redirection URIs that are allowed to utilized at the authorization endpoint.
        ///   post_logout_redirect_uris: [string], # Required. List of redirection URIs that end-user&apos;s User Agent can be redirected to after a logout has been performed
        /// at the end session endpoint.
        ///   client_secrets: [string], # Required. List of client secrets for a confidential clients.
        ///   client_certificate: string, # Optional. List of client certificate for a confidential clients. Certificates are specified in the PEM format.
        ///   back_channel_logout_uri: string, # Optional. Back-channel logout URI to be used when performing back-channel logouts according to the
        /// _&quot;OpenID Connect Back-Channel Logout 1.0&quot;_ specification.
        ///   requires_jwt_assertion: boolean, # Optional. Flag indicating if this client requires the use of JWT assertions
        ///   client_private_keys_jwt: [
        ///     {
        ///       kid: string, # Required. Key ID for the key.
        ///       pem_public_key: string, # Required. Public key specified in the PEM format.
        ///     }
        ///   ], # Optional. List of public keys, to be used for JWT assertions for confidential clients.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateClient(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.CreateClient");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateClientRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to delete a client. </summary>
        /// <param name="clientId"> Client Id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="clientId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="clientId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> ClientDeleteAsync(string clientId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(clientId, nameof(clientId));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.ClientDelete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateClientDeleteRequest(clientId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to delete a client. </summary>
        /// <param name="clientId"> Client Id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="clientId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="clientId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response ClientDelete(string clientId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(clientId, nameof(clientId));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.ClientDelete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateClientDeleteRequest(clientId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to read all OAuth2/OIDC clients. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArrayOfClient</c>:
        /// <code>{
        ///   client_id: string, # Required. OIDC client id
        ///   return_uris: [string], # Required. List of redirection URIs that are allowed to utilized at the authorization endpoint.
        ///   post_logout_redirect_uris: [string], # Required. List of redirection URIs that end-user&apos;s User Agent can be redirected to after a logout has been performed
        /// at the end session endpoint.
        ///   client_secrets: [string], # Required. List of client secrets for a confidential clients.
        ///   client_certificate: string, # Optional. List of client certificate for a confidential clients. Certificates are specified in the PEM format.
        ///   back_channel_logout_uri: string, # Optional. Back-channel logout URI to be used when performing back-channel logouts according to the
        /// _&quot;OpenID Connect Back-Channel Logout 1.0&quot;_ specification.
        ///   requires_jwt_assertion: boolean, # Optional. Flag indicating if this client requires the use of JWT assertions
        ///   client_private_keys_jwt: [
        ///     {
        ///       kid: string, # Required. Key ID for the key.
        ///       pem_public_key: string, # Required. Public key specified in the PEM format.
        ///     }
        ///   ], # Optional. List of public keys, to be used for JWT assertions for confidential clients.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> ClientsAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.Clients");
            scope.Start();
            try
            {
                using HttpMessage message = CreateClientsRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to read all OAuth2/OIDC clients. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArrayOfClient</c>:
        /// <code>{
        ///   client_id: string, # Required. OIDC client id
        ///   return_uris: [string], # Required. List of redirection URIs that are allowed to utilized at the authorization endpoint.
        ///   post_logout_redirect_uris: [string], # Required. List of redirection URIs that end-user&apos;s User Agent can be redirected to after a logout has been performed
        /// at the end session endpoint.
        ///   client_secrets: [string], # Required. List of client secrets for a confidential clients.
        ///   client_certificate: string, # Optional. List of client certificate for a confidential clients. Certificates are specified in the PEM format.
        ///   back_channel_logout_uri: string, # Optional. Back-channel logout URI to be used when performing back-channel logouts according to the
        /// _&quot;OpenID Connect Back-Channel Logout 1.0&quot;_ specification.
        ///   requires_jwt_assertion: boolean, # Optional. Flag indicating if this client requires the use of JWT assertions
        ///   client_private_keys_jwt: [
        ///     {
        ///       kid: string, # Required. Key ID for the key.
        ///       pem_public_key: string, # Required. Public key specified in the PEM format.
        ///     }
        ///   ], # Optional. List of public keys, to be used for JWT assertions for confidential clients.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Clients(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.Clients");
            scope.Start();
            try
            {
                using HttpMessage message = CreateClientsRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Starts a new logout session with Heimdall. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>LogoutCreateRequest</c>:
        /// <code>{
        ///   data: Dictionary&lt;string, object&gt;, # Optional. Arbitrary data (key/value pairs of data) to append to the created logout session.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogoutCreateRequestResponse</c>:
        /// <code>{
        ///   logout_sid: string, # Optional. Logout session identifier of the created logout session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateLogoutSessionAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.CreateLogoutSession");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLogoutSessionRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Starts a new logout session with Heimdall. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>LogoutCreateRequest</c>:
        /// <code>{
        ///   data: Dictionary&lt;string, object&gt;, # Optional. Arbitrary data (key/value pairs of data) to append to the created logout session.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogoutCreateRequestResponse</c>:
        /// <code>{
        ///   logout_sid: string, # Optional. Logout session identifier of the created logout session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateLogoutSession(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.CreateLogoutSession");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLogoutSessionRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Appends arbitrary data to an ongoing logout session. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>LogoutSessionDataRequest</c>:
        /// <code>{
        ///   logout_sid: string, # Optional. Logout session identifier of the ongoing logout session.
        ///   data: Dictionary&lt;string, object&gt;, # Optional. Arbitrary data (key/value pairs of data) to append to the ongoing logout session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AddDataToLogoutSessionAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.AddDataToLogoutSession");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddDataToLogoutSessionRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Appends arbitrary data to an ongoing logout session. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>LogoutSessionDataRequest</c>:
        /// <code>{
        ///   logout_sid: string, # Optional. Logout session identifier of the ongoing logout session.
        ///   data: Dictionary&lt;string, object&gt;, # Optional. Arbitrary data (key/value pairs of data) to append to the ongoing logout session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response AddDataToLogoutSession(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.AddDataToLogoutSession");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddDataToLogoutSessionRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves optional arbitrary data stored in the logout session. </summary>
        /// <param name="sid"> Logout session identifier of the ongoing logout session. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="sid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="sid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogoutSessionState</c>:
        /// <code>{
        ///   logout_sid: string, # Optional. Logout session identifier of the ongoing logout session.
        ///   json_data: Dictionary&lt;string, object&gt;, # Optional. Arbitrary data (key/value pairs of data) to append to the ongoing logout session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetLogoutSessionAsync(string sid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(sid, nameof(sid));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.GetLogoutSession");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogoutSessionRequest(sid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves optional arbitrary data stored in the logout session. </summary>
        /// <param name="sid"> Logout session identifier of the ongoing logout session. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="sid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="sid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogoutSessionState</c>:
        /// <code>{
        ///   logout_sid: string, # Optional. Logout session identifier of the ongoing logout session.
        ///   json_data: Dictionary&lt;string, object&gt;, # Optional. Arbitrary data (key/value pairs of data) to append to the ongoing logout session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetLogoutSession(string sid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(sid, nameof(sid));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.GetLogoutSession");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogoutSessionRequest(sid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an logout session. </summary>
        /// <param name="sid"> Logout session identifier of the ongoing logout session. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="sid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="sid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteLogoutSessionAsync(string sid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(sid, nameof(sid));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.DeleteLogoutSession");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLogoutSessionRequest(sid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an logout session. </summary>
        /// <param name="sid"> Logout session identifier of the ongoing logout session. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="sid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="sid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteLogoutSession(string sid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(sid, nameof(sid));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.DeleteLogoutSession");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLogoutSessionRequest(sid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to save a scope that can be requested by client applications. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>Scope</c>:
        /// <code>{
        ///   name: string, # Required. Name of scope (used in tokens for instance).
        ///   consent_label: string, # Optional. Label to display to end-users when asking for consent to grant the scope (human readable text).
        ///   requires_consent: boolean, # Optional. Should end-users be prompted for consent if a client application requests this scope.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> SaveScopeAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.SaveScope");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSaveScopeRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to save a scope that can be requested by client applications. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>Scope</c>:
        /// <code>{
        ///   name: string, # Required. Name of scope (used in tokens for instance).
        ///   consent_label: string, # Optional. Label to display to end-users when asking for consent to grant the scope (human readable text).
        ///   requires_consent: boolean, # Optional. Should end-users be prompted for consent if a client application requests this scope.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response SaveScope(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("HeimdallClient.SaveScope");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSaveScopeRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to delete a scope. </summary>
        /// <param name="scope"> Name of scope to delete. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="scope"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="scope"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> ScopeDeleteAsync(string scope, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(scope, nameof(scope));

            using var scope0 = ClientDiagnostics.CreateScope("HeimdallClient.ScopeDelete");
            scope0.Start();
            try
            {
                using HttpMessage message = CreateScopeDeleteRequest(scope, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to delete a scope. </summary>
        /// <param name="scope"> Name of scope to delete. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="scope"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="scope"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response ScopeDelete(string scope, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(scope, nameof(scope));

            using var scope0 = ClientDiagnostics.CreateScope("HeimdallClient.ScopeDelete");
            scope0.Start();
            try
            {
                using HttpMessage message = CreateScopeDeleteRequest(scope, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to read all scopes that can be requested by client applications. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArrayOfScope</c>:
        /// <code>{
        ///   name: string, # Required. Name of scope (used in tokens for instance).
        ///   consent_label: string, # Optional. Label to display to end-users when asking for consent to grant the scope (human readable text).
        ///   requires_consent: boolean, # Optional. Should end-users be prompted for consent if a client application requests this scope.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> ScopesAsync(RequestContext context = null)
        {
            using var scope0 = ClientDiagnostics.CreateScope("HeimdallClient.Scopes");
            scope0.Start();
            try
            {
                using HttpMessage message = CreateScopesRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> CRUD operation to read all scopes that can be requested by client applications. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArrayOfScope</c>:
        /// <code>{
        ///   name: string, # Required. Name of scope (used in tokens for instance).
        ///   consent_label: string, # Optional. Label to display to end-users when asking for consent to grant the scope (human readable text).
        ///   requires_consent: boolean, # Optional. Should end-users be prompted for consent if a client application requests this scope.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Scopes(RequestContext context = null)
        {
            using var scope0 = ClientDiagnostics.CreateScope("HeimdallClient.Scopes");
            scope0.Start();
            try
            {
                using HttpMessage message = CreateScopesRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves the meta data associated to a single session. </summary>
        /// <param name="sid"> Session identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="sid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="sid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SessionState</c>:
        /// <code>{
        ///   json_data: Dictionary&lt;string, object&gt;, # Optional. Dynamic data (if any) associated with the session, represented as key/value pairs.
        ///   exp: string (ISO 8601 Format), # Required. Timestamp for when the session expires.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetSessionAsync(string sid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(sid, nameof(sid));

            using var scope0 = ClientDiagnostics.CreateScope("HeimdallClient.GetSession");
            scope0.Start();
            try
            {
                using HttpMessage message = CreateGetSessionRequest(sid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves the meta data associated to a single session. </summary>
        /// <param name="sid"> Session identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="sid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="sid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SessionState</c>:
        /// <code>{
        ///   json_data: Dictionary&lt;string, object&gt;, # Optional. Dynamic data (if any) associated with the session, represented as key/value pairs.
        ///   exp: string (ISO 8601 Format), # Required. Timestamp for when the session expires.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetSession(string sid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(sid, nameof(sid));

            using var scope0 = ClientDiagnostics.CreateScope("HeimdallClient.GetSession");
            scope0.Start();
            try
            {
                using HttpMessage message = CreateGetSessionRequest(sid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Appends arbitrary data to an session. This can be useful in more complex authentication scenarios, where you have
        /// a need to store data related to the end-users single sign-on session. An example use case of session data
        /// is identity federation. When authenticating the user via a third party IdP, you might want to store data related
        /// to the federation - an example could be storing the id token from the federated identity provider. The stored id
        /// token could then be used as the `id_token_hint` in the case of a federated logout of the third party IdP.
        /// Storing data in the session allows your frontend to be stateless, as you do not need to handle distributed
        /// persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SessionDataRequest</c>:
        /// <code>{
        ///   sid: string, # Required. Session identifier.
        ///   data: Dictionary&lt;string, object&gt;, # Required. Arbitrary data to append to the session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AddDataToSessionAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope0 = ClientDiagnostics.CreateScope("HeimdallClient.AddDataToSession");
            scope0.Start();
            try
            {
                using HttpMessage message = CreateAddDataToSessionRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Appends arbitrary data to an session. This can be useful in more complex authentication scenarios, where you have
        /// a need to store data related to the end-users single sign-on session. An example use case of session data
        /// is identity federation. When authenticating the user via a third party IdP, you might want to store data related
        /// to the federation - an example could be storing the id token from the federated identity provider. The stored id
        /// token could then be used as the `id_token_hint` in the case of a federated logout of the third party IdP.
        /// Storing data in the session allows your frontend to be stateless, as you do not need to handle distributed
        /// persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SessionDataRequest</c>:
        /// <code>{
        ///   sid: string, # Required. Session identifier.
        ///   data: Dictionary&lt;string, object&gt;, # Required. Arbitrary data to append to the session.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response AddDataToSession(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope0 = ClientDiagnostics.CreateScope("HeimdallClient.AddDataToSession");
            scope0.Start();
            try
            {
                using HttpMessage message = CreateAddDataToSessionRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Performs log out of an end-user in accordance with the _&quot;OpenID Connect RP-Initiated Logout 1.0&quot;_ specification.
        /// This operation is usually the first step when creating a login page
        /// at the OAuth 2.0 end session endpoint. This operation expects the original query string as well as a session cookie
        /// if one exists. The operation will always return exactly one of the following JSON objects (all but one will have `null` values):
        /// `final_response`, `logout_prompt`, `error`.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>LogoutRequest</c>:
        /// <code>{
        ///   query: string, # Required. The URI query string received at the OAuth 2.0/OIDC end session endpoint. This must be the raw query string (Heimdall will do the decoding).
        ///   session: string, # Optional. The session identifier (if any), which has been stored in a browser HTTP only cookie. This is used to identify  the users single sign-on session.
        ///   confirm_logout: boolean, # Required. Flag indicating if the end-user has given their consent and confirmed they want to end the session. 
        /// If you do not wish to prompt the end-user, you can set this flag always `true`.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogoutResponse</c>:
        /// <code>{
        ///   final_response: {
        ///     uri: string, # Optional. The URI to which the user agent should be redirected.
        ///   }, # Optional. Indicates a final response that redirects to the client application. The frontend is required to redirect the user-agent (the browser)
        /// to the client application with the specified response, using a `303 See Other` HTTP response status code.
        ///   error: {
        ///     error: string, # Required. Error to display to the end-user.
        ///   }, # Optional. Indicates that the logout request is invalid. The frontend must display an error to the end-user an must
        /// not redirect back to the client application.
        ///   logout_prompt: {
        ///     sub: string, # Required. The identifier for the end-user (sub)
        ///     session_data: Dictionary&lt;string, object&gt;, # Required. Dynamic data (if any) associated with the session, represented as key/value pairs.
        ///   }, # Optional. Indicates that the logout request is valid, and the user needs to be prompted to confirm that they
        /// consent to end the session. The subject identifier along with any stored session data is included
        /// in this response. This makes it convenient to implement custom logout logic in your frontend.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> RpInitiatedLogoutAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope0 = ClientDiagnostics.CreateScope("HeimdallClient.RpInitiatedLogout");
            scope0.Start();
            try
            {
                using HttpMessage message = CreateRpInitiatedLogoutRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Performs log out of an end-user in accordance with the _&quot;OpenID Connect RP-Initiated Logout 1.0&quot;_ specification.
        /// This operation is usually the first step when creating a login page
        /// at the OAuth 2.0 end session endpoint. This operation expects the original query string as well as a session cookie
        /// if one exists. The operation will always return exactly one of the following JSON objects (all but one will have `null` values):
        /// `final_response`, `logout_prompt`, `error`.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>LogoutRequest</c>:
        /// <code>{
        ///   query: string, # Required. The URI query string received at the OAuth 2.0/OIDC end session endpoint. This must be the raw query string (Heimdall will do the decoding).
        ///   session: string, # Optional. The session identifier (if any), which has been stored in a browser HTTP only cookie. This is used to identify  the users single sign-on session.
        ///   confirm_logout: boolean, # Required. Flag indicating if the end-user has given their consent and confirmed they want to end the session. 
        /// If you do not wish to prompt the end-user, you can set this flag always `true`.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogoutResponse</c>:
        /// <code>{
        ///   final_response: {
        ///     uri: string, # Optional. The URI to which the user agent should be redirected.
        ///   }, # Optional. Indicates a final response that redirects to the client application. The frontend is required to redirect the user-agent (the browser)
        /// to the client application with the specified response, using a `303 See Other` HTTP response status code.
        ///   error: {
        ///     error: string, # Required. Error to display to the end-user.
        ///   }, # Optional. Indicates that the logout request is invalid. The frontend must display an error to the end-user an must
        /// not redirect back to the client application.
        ///   logout_prompt: {
        ///     sub: string, # Required. The identifier for the end-user (sub)
        ///     session_data: Dictionary&lt;string, object&gt;, # Required. Dynamic data (if any) associated with the session, represented as key/value pairs.
        ///   }, # Optional. Indicates that the logout request is valid, and the user needs to be prompted to confirm that they
        /// consent to end the session. The subject identifier along with any stored session data is included
        /// in this response. This makes it convenient to implement custom logout logic in your frontend.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response RpInitiatedLogout(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope0 = ClientDiagnostics.CreateScope("HeimdallClient.RpInitiatedLogout");
            scope0.Start();
            try
            {
                using HttpMessage message = CreateRpInitiatedLogoutRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateAuthorizePeekRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/authz/peek", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAuthorizeRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/authz/authorize", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateConsentAcceptRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/authz/consent", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAuthorizeAcceptRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/authz/accept", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAuthorizeDataRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/authz/authorize/data", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAuthorizeDataGetRequest(string authSid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/authz/authorize/data/", false);
            uri.AppendPath(authSid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateSaveIndividualClaimRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200400401);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/claim", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateClaimDeleteRequest(string claim, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200400401404);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/claims/", false);
            uri.AppendPath(claim, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateIndividualClaimsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/claims", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateClientRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200400401);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/client", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateClientDeleteRequest(string clientId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200400401404);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/clients/", false);
            uri.AppendPath(clientId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateClientsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/clients", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateLogoutSessionRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/logout_session", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddDataToLogoutSessionRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/logout_session/data", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLogoutSessionRequest(string sid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401404);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/logout_session/", false);
            uri.AppendPath(sid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteLogoutSessionRequest(string sid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/logout_session/", false);
            uri.AppendPath(sid, true);
            request.Uri = uri;
            return message;
        }

        internal HttpMessage CreateSaveScopeRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200400401);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/scope", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateScopeDeleteRequest(string scope, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200400401404);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/scopes/", false);
            uri.AppendPath(scope, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateScopesRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/scopes", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSessionRequest(string sid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401404);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/session/", false);
            uri.AppendPath(sid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddDataToSessionRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/session/data", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateRpInitiatedLogoutRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200401);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/session/rp_initiated_logout", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static ResponseClassifier _responseClassifier200401;
        private static ResponseClassifier ResponseClassifier200401 => _responseClassifier200401 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 401 });
        private static ResponseClassifier _responseClassifier200400401;
        private static ResponseClassifier ResponseClassifier200400401 => _responseClassifier200400401 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 400, 401 });
        private static ResponseClassifier _responseClassifier200400401404;
        private static ResponseClassifier ResponseClassifier200400401404 => _responseClassifier200400401404 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 400, 401, 404 });
        private static ResponseClassifier _responseClassifier200401404;
        private static ResponseClassifier ResponseClassifier200401404 => _responseClassifier200401404 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 401, 404 });
    }
}
