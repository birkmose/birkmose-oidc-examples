/*
 * Heimdall
 *
 * # Introduction    The Heimdall backchannel API is a [RESTful](https://wikipedia.org/wiki/Representational_state_transfer) API that allows you to do authorizations, manage sessions, do CRUD on various objects, etc.          
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using heimdall_client.Client;
using heimdall_client.Model;

namespace heimdall_client.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthzApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create authorization session
        /// </summary>
        /// <remarks>
        ///  Starts a new authorization session with Heimdall. This is usually the first step when creating a login page  at the OAuth 2.0 authorization endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeRequest"></param>
        /// <returns>AuthResponse</returns>
        AuthResponse Authorize(AuthorizeRequest authorizeRequest);

        /// <summary>
        /// Create authorization session
        /// </summary>
        /// <remarks>
        ///  Starts a new authorization session with Heimdall. This is usually the first step when creating a login page  at the OAuth 2.0 authorization endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeRequest"></param>
        /// <returns>ApiResponse of AuthResponse</returns>
        ApiResponse<AuthResponse> AuthorizeWithHttpInfo(AuthorizeRequest authorizeRequest);
        /// <summary>
        /// Accept authorization
        /// </summary>
        /// <remarks>
        /// Registers an end-user as having been authorized. Registers the identity of the authenthicated user in the authorization session.  This is called after the user has been authenthicated by whatever mechanisms used by your frontend to authenthicate   the end-user. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeAcceptRequest"></param>
        /// <returns>AuthResponse</returns>
        AuthResponse AuthorizeAccept(AuthorizeAcceptRequest authorizeAcceptRequest);

        /// <summary>
        /// Accept authorization
        /// </summary>
        /// <remarks>
        /// Registers an end-user as having been authorized. Registers the identity of the authenthicated user in the authorization session.  This is called after the user has been authenthicated by whatever mechanisms used by your frontend to authenthicate   the end-user. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeAcceptRequest"></param>
        /// <returns>ApiResponse of AuthResponse</returns>
        ApiResponse<AuthResponse> AuthorizeAcceptWithHttpInfo(AuthorizeAcceptRequest authorizeAcceptRequest);
        /// <summary>
        /// Append authorization data
        /// </summary>
        /// <remarks>
        /// Appends arbitrary data to an authorization session. This can be useful in more complex authentication scenarios.  For instance, if you require multi-factor authentication, and want to store the challenge that you send to   end-user via some other communication channel (such as email, SMS, etc). Another example is if you authenticate  users using identity federation with another OIDC provider. If your request to the third party IdP includes a nonce  you can store this in the authorization sessions data store.   Storing data in the authorization session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeDataRequest"></param>
        /// <returns></returns>
        void AuthorizeData(AuthorizeDataRequest authorizeDataRequest);

        /// <summary>
        /// Append authorization data
        /// </summary>
        /// <remarks>
        /// Appends arbitrary data to an authorization session. This can be useful in more complex authentication scenarios.  For instance, if you require multi-factor authentication, and want to store the challenge that you send to   end-user via some other communication channel (such as email, SMS, etc). Another example is if you authenticate  users using identity federation with another OIDC provider. If your request to the third party IdP includes a nonce  you can store this in the authorization sessions data store.   Storing data in the authorization session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeDataRequest"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AuthorizeDataWithHttpInfo(AuthorizeDataRequest authorizeDataRequest);
        /// <summary>
        /// Get authorization data
        /// </summary>
        /// <remarks>
        /// Retrieves optional arbitrary data stored in the authorization session.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSid">Authorization session identifier of the ongoing authorization session.</param>
        /// <returns>AuthSessionData</returns>
        AuthSessionData AuthorizeDataGet(string authSid);

        /// <summary>
        /// Get authorization data
        /// </summary>
        /// <remarks>
        /// Retrieves optional arbitrary data stored in the authorization session.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSid">Authorization session identifier of the ongoing authorization session.</param>
        /// <returns>ApiResponse of AuthSessionData</returns>
        ApiResponse<AuthSessionData> AuthorizeDataGetWithHttpInfo(string authSid);
        /// <summary>
        /// Peek authorization request
        /// </summary>
        /// <remarks>
        /// Peeks the query payload of an authorization request without starting an authorization session,   which can be useful in several scenarios.                 It allows you to determine if the authorization request is valid, and   if it is valid it allows you to decode the query payload, which you can use to control custom business logic.  An example could be if your implementation allows federation with multiple identity providers, but perhaps not all   federation providers are valid for all clients. Using the peek operation you can peek the client id, and decide   which single sign-on session cookie to use for the &#x60;/authz/authorize&#x60; operation.                Another example where the peek operation can be particularly useful, is for pushed authorization requests (PAR)  allowing you to peek the stored content of the request, without having to consume the PAR Uri.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizePeekRequest"></param>
        /// <returns>AuthPeekResponse</returns>
        AuthPeekResponse AuthorizePeek(AuthorizePeekRequest authorizePeekRequest);

        /// <summary>
        /// Peek authorization request
        /// </summary>
        /// <remarks>
        /// Peeks the query payload of an authorization request without starting an authorization session,   which can be useful in several scenarios.                 It allows you to determine if the authorization request is valid, and   if it is valid it allows you to decode the query payload, which you can use to control custom business logic.  An example could be if your implementation allows federation with multiple identity providers, but perhaps not all   federation providers are valid for all clients. Using the peek operation you can peek the client id, and decide   which single sign-on session cookie to use for the &#x60;/authz/authorize&#x60; operation.                Another example where the peek operation can be particularly useful, is for pushed authorization requests (PAR)  allowing you to peek the stored content of the request, without having to consume the PAR Uri.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizePeekRequest"></param>
        /// <returns>ApiResponse of AuthPeekResponse</returns>
        ApiResponse<AuthPeekResponse> AuthorizePeekWithHttpInfo(AuthorizePeekRequest authorizePeekRequest);
        /// <summary>
        /// Accept consent
        /// </summary>
        /// <remarks>
        /// Finalizes an authorization session with Heimdall. This is the final step carried out before the user agent will be redirected  to the client application. The accept consent operation allow you to specify which claims and scopes the user consented to.  Depending on your needs, you can also automatically accept claims without having asked the user for consent (this can be common  in some type of enterprise applications for instance). The accept consent also provides an opportunity to enriched the generated  token(s) with additional claims. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentAcceptRequest"></param>
        /// <returns>AuthResponse</returns>
        AuthResponse ConsentAccept(ConsentAcceptRequest consentAcceptRequest);

        /// <summary>
        /// Accept consent
        /// </summary>
        /// <remarks>
        /// Finalizes an authorization session with Heimdall. This is the final step carried out before the user agent will be redirected  to the client application. The accept consent operation allow you to specify which claims and scopes the user consented to.  Depending on your needs, you can also automatically accept claims without having asked the user for consent (this can be common  in some type of enterprise applications for instance). The accept consent also provides an opportunity to enriched the generated  token(s) with additional claims. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentAcceptRequest"></param>
        /// <returns>ApiResponse of AuthResponse</returns>
        ApiResponse<AuthResponse> ConsentAcceptWithHttpInfo(ConsentAcceptRequest consentAcceptRequest);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthzApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Create authorization session
        /// </summary>
        /// <remarks>
        ///  Starts a new authorization session with Heimdall. This is usually the first step when creating a login page  at the OAuth 2.0 authorization endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthResponse</returns>
        System.Threading.Tasks.Task<AuthResponse> AuthorizeAsync(AuthorizeRequest authorizeRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create authorization session
        /// </summary>
        /// <remarks>
        ///  Starts a new authorization session with Heimdall. This is usually the first step when creating a login page  at the OAuth 2.0 authorization endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AuthResponse>> AuthorizeWithHttpInfoAsync(AuthorizeRequest authorizeRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Accept authorization
        /// </summary>
        /// <remarks>
        /// Registers an end-user as having been authorized. Registers the identity of the authenthicated user in the authorization session.  This is called after the user has been authenthicated by whatever mechanisms used by your frontend to authenthicate   the end-user. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeAcceptRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthResponse</returns>
        System.Threading.Tasks.Task<AuthResponse> AuthorizeAcceptAsync(AuthorizeAcceptRequest authorizeAcceptRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Accept authorization
        /// </summary>
        /// <remarks>
        /// Registers an end-user as having been authorized. Registers the identity of the authenthicated user in the authorization session.  This is called after the user has been authenthicated by whatever mechanisms used by your frontend to authenthicate   the end-user. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeAcceptRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AuthResponse>> AuthorizeAcceptWithHttpInfoAsync(AuthorizeAcceptRequest authorizeAcceptRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Append authorization data
        /// </summary>
        /// <remarks>
        /// Appends arbitrary data to an authorization session. This can be useful in more complex authentication scenarios.  For instance, if you require multi-factor authentication, and want to store the challenge that you send to   end-user via some other communication channel (such as email, SMS, etc). Another example is if you authenticate  users using identity federation with another OIDC provider. If your request to the third party IdP includes a nonce  you can store this in the authorization sessions data store.   Storing data in the authorization session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AuthorizeDataAsync(AuthorizeDataRequest authorizeDataRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Append authorization data
        /// </summary>
        /// <remarks>
        /// Appends arbitrary data to an authorization session. This can be useful in more complex authentication scenarios.  For instance, if you require multi-factor authentication, and want to store the challenge that you send to   end-user via some other communication channel (such as email, SMS, etc). Another example is if you authenticate  users using identity federation with another OIDC provider. If your request to the third party IdP includes a nonce  you can store this in the authorization sessions data store.   Storing data in the authorization session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AuthorizeDataWithHttpInfoAsync(AuthorizeDataRequest authorizeDataRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get authorization data
        /// </summary>
        /// <remarks>
        /// Retrieves optional arbitrary data stored in the authorization session.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSid">Authorization session identifier of the ongoing authorization session.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthSessionData</returns>
        System.Threading.Tasks.Task<AuthSessionData> AuthorizeDataGetAsync(string authSid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get authorization data
        /// </summary>
        /// <remarks>
        /// Retrieves optional arbitrary data stored in the authorization session.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSid">Authorization session identifier of the ongoing authorization session.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthSessionData)</returns>
        System.Threading.Tasks.Task<ApiResponse<AuthSessionData>> AuthorizeDataGetWithHttpInfoAsync(string authSid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Peek authorization request
        /// </summary>
        /// <remarks>
        /// Peeks the query payload of an authorization request without starting an authorization session,   which can be useful in several scenarios.                 It allows you to determine if the authorization request is valid, and   if it is valid it allows you to decode the query payload, which you can use to control custom business logic.  An example could be if your implementation allows federation with multiple identity providers, but perhaps not all   federation providers are valid for all clients. Using the peek operation you can peek the client id, and decide   which single sign-on session cookie to use for the &#x60;/authz/authorize&#x60; operation.                Another example where the peek operation can be particularly useful, is for pushed authorization requests (PAR)  allowing you to peek the stored content of the request, without having to consume the PAR Uri.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizePeekRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthPeekResponse</returns>
        System.Threading.Tasks.Task<AuthPeekResponse> AuthorizePeekAsync(AuthorizePeekRequest authorizePeekRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Peek authorization request
        /// </summary>
        /// <remarks>
        /// Peeks the query payload of an authorization request without starting an authorization session,   which can be useful in several scenarios.                 It allows you to determine if the authorization request is valid, and   if it is valid it allows you to decode the query payload, which you can use to control custom business logic.  An example could be if your implementation allows federation with multiple identity providers, but perhaps not all   federation providers are valid for all clients. Using the peek operation you can peek the client id, and decide   which single sign-on session cookie to use for the &#x60;/authz/authorize&#x60; operation.                Another example where the peek operation can be particularly useful, is for pushed authorization requests (PAR)  allowing you to peek the stored content of the request, without having to consume the PAR Uri.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizePeekRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthPeekResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AuthPeekResponse>> AuthorizePeekWithHttpInfoAsync(AuthorizePeekRequest authorizePeekRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Accept consent
        /// </summary>
        /// <remarks>
        /// Finalizes an authorization session with Heimdall. This is the final step carried out before the user agent will be redirected  to the client application. The accept consent operation allow you to specify which claims and scopes the user consented to.  Depending on your needs, you can also automatically accept claims without having asked the user for consent (this can be common  in some type of enterprise applications for instance). The accept consent also provides an opportunity to enriched the generated  token(s) with additional claims. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentAcceptRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthResponse</returns>
        System.Threading.Tasks.Task<AuthResponse> ConsentAcceptAsync(ConsentAcceptRequest consentAcceptRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Accept consent
        /// </summary>
        /// <remarks>
        /// Finalizes an authorization session with Heimdall. This is the final step carried out before the user agent will be redirected  to the client application. The accept consent operation allow you to specify which claims and scopes the user consented to.  Depending on your needs, you can also automatically accept claims without having asked the user for consent (this can be common  in some type of enterprise applications for instance). The accept consent also provides an opportunity to enriched the generated  token(s) with additional claims. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </remarks>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentAcceptRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AuthResponse>> ConsentAcceptWithHttpInfoAsync(ConsentAcceptRequest consentAcceptRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthzApi : IAuthzApiSync, IAuthzApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class AuthzApi : IAuthzApi
    {
        private heimdall_client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthzApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AuthzApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthzApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AuthzApi(string basePath)
        {
            this.Configuration = heimdall_client.Client.Configuration.MergeConfigurations(
                heimdall_client.Client.GlobalConfiguration.Instance,
                new heimdall_client.Client.Configuration { BasePath = basePath }
            );
            this.Client = new heimdall_client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new heimdall_client.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = heimdall_client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthzApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public AuthzApi(heimdall_client.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = heimdall_client.Client.Configuration.MergeConfigurations(
                heimdall_client.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new heimdall_client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new heimdall_client.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = heimdall_client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthzApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public AuthzApi(heimdall_client.Client.ISynchronousClient client, heimdall_client.Client.IAsynchronousClient asyncClient, heimdall_client.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = heimdall_client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public heimdall_client.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public heimdall_client.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public heimdall_client.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public heimdall_client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Create authorization session  Starts a new authorization session with Heimdall. This is usually the first step when creating a login page  at the OAuth 2.0 authorization endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeRequest"></param>
        /// <returns>AuthResponse</returns>
        public AuthResponse Authorize(AuthorizeRequest authorizeRequest)
        {
            heimdall_client.Client.ApiResponse<AuthResponse> localVarResponse = AuthorizeWithHttpInfo(authorizeRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create authorization session  Starts a new authorization session with Heimdall. This is usually the first step when creating a login page  at the OAuth 2.0 authorization endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeRequest"></param>
        /// <returns>ApiResponse of AuthResponse</returns>
        public heimdall_client.Client.ApiResponse<AuthResponse> AuthorizeWithHttpInfo(AuthorizeRequest authorizeRequest)
        {
            // verify the required parameter 'authorizeRequest' is set
            if (authorizeRequest == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'authorizeRequest' when calling AuthzApi->Authorize");
            }

            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = authorizeRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<AuthResponse>("/authz/authorize", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Authorize", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create authorization session  Starts a new authorization session with Heimdall. This is usually the first step when creating a login page  at the OAuth 2.0 authorization endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthResponse</returns>
        public async System.Threading.Tasks.Task<AuthResponse> AuthorizeAsync(AuthorizeRequest authorizeRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            heimdall_client.Client.ApiResponse<AuthResponse> localVarResponse = await AuthorizeWithHttpInfoAsync(authorizeRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create authorization session  Starts a new authorization session with Heimdall. This is usually the first step when creating a login page  at the OAuth 2.0 authorization endpoint. This operation expects the original query string as well as a session cookie  if one exists. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthResponse)</returns>
        public async System.Threading.Tasks.Task<heimdall_client.Client.ApiResponse<AuthResponse>> AuthorizeWithHttpInfoAsync(AuthorizeRequest authorizeRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'authorizeRequest' is set
            if (authorizeRequest == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'authorizeRequest' when calling AuthzApi->Authorize");
            }


            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = authorizeRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<AuthResponse>("/authz/authorize", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Authorize", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Accept authorization Registers an end-user as having been authorized. Registers the identity of the authenthicated user in the authorization session.  This is called after the user has been authenthicated by whatever mechanisms used by your frontend to authenthicate   the end-user. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeAcceptRequest"></param>
        /// <returns>AuthResponse</returns>
        public AuthResponse AuthorizeAccept(AuthorizeAcceptRequest authorizeAcceptRequest)
        {
            heimdall_client.Client.ApiResponse<AuthResponse> localVarResponse = AuthorizeAcceptWithHttpInfo(authorizeAcceptRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept authorization Registers an end-user as having been authorized. Registers the identity of the authenthicated user in the authorization session.  This is called after the user has been authenthicated by whatever mechanisms used by your frontend to authenthicate   the end-user. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeAcceptRequest"></param>
        /// <returns>ApiResponse of AuthResponse</returns>
        public heimdall_client.Client.ApiResponse<AuthResponse> AuthorizeAcceptWithHttpInfo(AuthorizeAcceptRequest authorizeAcceptRequest)
        {
            // verify the required parameter 'authorizeAcceptRequest' is set
            if (authorizeAcceptRequest == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'authorizeAcceptRequest' when calling AuthzApi->AuthorizeAccept");
            }

            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = authorizeAcceptRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<AuthResponse>("/authz/accept", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AuthorizeAccept", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Accept authorization Registers an end-user as having been authorized. Registers the identity of the authenthicated user in the authorization session.  This is called after the user has been authenthicated by whatever mechanisms used by your frontend to authenthicate   the end-user. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeAcceptRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthResponse</returns>
        public async System.Threading.Tasks.Task<AuthResponse> AuthorizeAcceptAsync(AuthorizeAcceptRequest authorizeAcceptRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            heimdall_client.Client.ApiResponse<AuthResponse> localVarResponse = await AuthorizeAcceptWithHttpInfoAsync(authorizeAcceptRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept authorization Registers an end-user as having been authorized. Registers the identity of the authenthicated user in the authorization session.  This is called after the user has been authenthicated by whatever mechanisms used by your frontend to authenthicate   the end-user. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeAcceptRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthResponse)</returns>
        public async System.Threading.Tasks.Task<heimdall_client.Client.ApiResponse<AuthResponse>> AuthorizeAcceptWithHttpInfoAsync(AuthorizeAcceptRequest authorizeAcceptRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'authorizeAcceptRequest' is set
            if (authorizeAcceptRequest == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'authorizeAcceptRequest' when calling AuthzApi->AuthorizeAccept");
            }


            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = authorizeAcceptRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<AuthResponse>("/authz/accept", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AuthorizeAccept", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Append authorization data Appends arbitrary data to an authorization session. This can be useful in more complex authentication scenarios.  For instance, if you require multi-factor authentication, and want to store the challenge that you send to   end-user via some other communication channel (such as email, SMS, etc). Another example is if you authenticate  users using identity federation with another OIDC provider. If your request to the third party IdP includes a nonce  you can store this in the authorization sessions data store.   Storing data in the authorization session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeDataRequest"></param>
        /// <returns></returns>
        public void AuthorizeData(AuthorizeDataRequest authorizeDataRequest)
        {
            AuthorizeDataWithHttpInfo(authorizeDataRequest);
        }

        /// <summary>
        /// Append authorization data Appends arbitrary data to an authorization session. This can be useful in more complex authentication scenarios.  For instance, if you require multi-factor authentication, and want to store the challenge that you send to   end-user via some other communication channel (such as email, SMS, etc). Another example is if you authenticate  users using identity federation with another OIDC provider. If your request to the third party IdP includes a nonce  you can store this in the authorization sessions data store.   Storing data in the authorization session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeDataRequest"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public heimdall_client.Client.ApiResponse<Object> AuthorizeDataWithHttpInfo(AuthorizeDataRequest authorizeDataRequest)
        {
            // verify the required parameter 'authorizeDataRequest' is set
            if (authorizeDataRequest == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'authorizeDataRequest' when calling AuthzApi->AuthorizeData");
            }

            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = authorizeDataRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/authz/authorize/data", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AuthorizeData", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Append authorization data Appends arbitrary data to an authorization session. This can be useful in more complex authentication scenarios.  For instance, if you require multi-factor authentication, and want to store the challenge that you send to   end-user via some other communication channel (such as email, SMS, etc). Another example is if you authenticate  users using identity federation with another OIDC provider. If your request to the third party IdP includes a nonce  you can store this in the authorization sessions data store.   Storing data in the authorization session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AuthorizeDataAsync(AuthorizeDataRequest authorizeDataRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await AuthorizeDataWithHttpInfoAsync(authorizeDataRequest, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Append authorization data Appends arbitrary data to an authorization session. This can be useful in more complex authentication scenarios.  For instance, if you require multi-factor authentication, and want to store the challenge that you send to   end-user via some other communication channel (such as email, SMS, etc). Another example is if you authenticate  users using identity federation with another OIDC provider. If your request to the third party IdP includes a nonce  you can store this in the authorization sessions data store.   Storing data in the authorization session allows your frontend to be stateless, as you do not need to handle distributed  persisted state yourself, you can simply re-use the existing storage mechanism utilized by Heimdall.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizeDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<heimdall_client.Client.ApiResponse<Object>> AuthorizeDataWithHttpInfoAsync(AuthorizeDataRequest authorizeDataRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'authorizeDataRequest' is set
            if (authorizeDataRequest == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'authorizeDataRequest' when calling AuthzApi->AuthorizeData");
            }


            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = authorizeDataRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/authz/authorize/data", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AuthorizeData", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get authorization data Retrieves optional arbitrary data stored in the authorization session.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSid">Authorization session identifier of the ongoing authorization session.</param>
        /// <returns>AuthSessionData</returns>
        public AuthSessionData AuthorizeDataGet(string authSid)
        {
            heimdall_client.Client.ApiResponse<AuthSessionData> localVarResponse = AuthorizeDataGetWithHttpInfo(authSid);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get authorization data Retrieves optional arbitrary data stored in the authorization session.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSid">Authorization session identifier of the ongoing authorization session.</param>
        /// <returns>ApiResponse of AuthSessionData</returns>
        public heimdall_client.Client.ApiResponse<AuthSessionData> AuthorizeDataGetWithHttpInfo(string authSid)
        {
            // verify the required parameter 'authSid' is set
            if (authSid == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'authSid' when calling AuthzApi->AuthorizeDataGet");
            }

            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("auth_sid", heimdall_client.Client.ClientUtils.ParameterToString(authSid)); // path parameter

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<AuthSessionData>("/authz/authorize/data/{auth_sid}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AuthorizeDataGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get authorization data Retrieves optional arbitrary data stored in the authorization session.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSid">Authorization session identifier of the ongoing authorization session.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthSessionData</returns>
        public async System.Threading.Tasks.Task<AuthSessionData> AuthorizeDataGetAsync(string authSid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            heimdall_client.Client.ApiResponse<AuthSessionData> localVarResponse = await AuthorizeDataGetWithHttpInfoAsync(authSid, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get authorization data Retrieves optional arbitrary data stored in the authorization session.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authSid">Authorization session identifier of the ongoing authorization session.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthSessionData)</returns>
        public async System.Threading.Tasks.Task<heimdall_client.Client.ApiResponse<AuthSessionData>> AuthorizeDataGetWithHttpInfoAsync(string authSid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'authSid' is set
            if (authSid == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'authSid' when calling AuthzApi->AuthorizeDataGet");
            }


            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("auth_sid", heimdall_client.Client.ClientUtils.ParameterToString(authSid)); // path parameter

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<AuthSessionData>("/authz/authorize/data/{auth_sid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AuthorizeDataGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Peek authorization request Peeks the query payload of an authorization request without starting an authorization session,   which can be useful in several scenarios.                 It allows you to determine if the authorization request is valid, and   if it is valid it allows you to decode the query payload, which you can use to control custom business logic.  An example could be if your implementation allows federation with multiple identity providers, but perhaps not all   federation providers are valid for all clients. Using the peek operation you can peek the client id, and decide   which single sign-on session cookie to use for the &#x60;/authz/authorize&#x60; operation.                Another example where the peek operation can be particularly useful, is for pushed authorization requests (PAR)  allowing you to peek the stored content of the request, without having to consume the PAR Uri.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizePeekRequest"></param>
        /// <returns>AuthPeekResponse</returns>
        public AuthPeekResponse AuthorizePeek(AuthorizePeekRequest authorizePeekRequest)
        {
            heimdall_client.Client.ApiResponse<AuthPeekResponse> localVarResponse = AuthorizePeekWithHttpInfo(authorizePeekRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Peek authorization request Peeks the query payload of an authorization request without starting an authorization session,   which can be useful in several scenarios.                 It allows you to determine if the authorization request is valid, and   if it is valid it allows you to decode the query payload, which you can use to control custom business logic.  An example could be if your implementation allows federation with multiple identity providers, but perhaps not all   federation providers are valid for all clients. Using the peek operation you can peek the client id, and decide   which single sign-on session cookie to use for the &#x60;/authz/authorize&#x60; operation.                Another example where the peek operation can be particularly useful, is for pushed authorization requests (PAR)  allowing you to peek the stored content of the request, without having to consume the PAR Uri.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizePeekRequest"></param>
        /// <returns>ApiResponse of AuthPeekResponse</returns>
        public heimdall_client.Client.ApiResponse<AuthPeekResponse> AuthorizePeekWithHttpInfo(AuthorizePeekRequest authorizePeekRequest)
        {
            // verify the required parameter 'authorizePeekRequest' is set
            if (authorizePeekRequest == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'authorizePeekRequest' when calling AuthzApi->AuthorizePeek");
            }

            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = authorizePeekRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<AuthPeekResponse>("/authz/peek", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AuthorizePeek", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Peek authorization request Peeks the query payload of an authorization request without starting an authorization session,   which can be useful in several scenarios.                 It allows you to determine if the authorization request is valid, and   if it is valid it allows you to decode the query payload, which you can use to control custom business logic.  An example could be if your implementation allows federation with multiple identity providers, but perhaps not all   federation providers are valid for all clients. Using the peek operation you can peek the client id, and decide   which single sign-on session cookie to use for the &#x60;/authz/authorize&#x60; operation.                Another example where the peek operation can be particularly useful, is for pushed authorization requests (PAR)  allowing you to peek the stored content of the request, without having to consume the PAR Uri.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizePeekRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthPeekResponse</returns>
        public async System.Threading.Tasks.Task<AuthPeekResponse> AuthorizePeekAsync(AuthorizePeekRequest authorizePeekRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            heimdall_client.Client.ApiResponse<AuthPeekResponse> localVarResponse = await AuthorizePeekWithHttpInfoAsync(authorizePeekRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Peek authorization request Peeks the query payload of an authorization request without starting an authorization session,   which can be useful in several scenarios.                 It allows you to determine if the authorization request is valid, and   if it is valid it allows you to decode the query payload, which you can use to control custom business logic.  An example could be if your implementation allows federation with multiple identity providers, but perhaps not all   federation providers are valid for all clients. Using the peek operation you can peek the client id, and decide   which single sign-on session cookie to use for the &#x60;/authz/authorize&#x60; operation.                Another example where the peek operation can be particularly useful, is for pushed authorization requests (PAR)  allowing you to peek the stored content of the request, without having to consume the PAR Uri.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorizePeekRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthPeekResponse)</returns>
        public async System.Threading.Tasks.Task<heimdall_client.Client.ApiResponse<AuthPeekResponse>> AuthorizePeekWithHttpInfoAsync(AuthorizePeekRequest authorizePeekRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'authorizePeekRequest' is set
            if (authorizePeekRequest == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'authorizePeekRequest' when calling AuthzApi->AuthorizePeek");
            }


            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = authorizePeekRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<AuthPeekResponse>("/authz/peek", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AuthorizePeek", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Accept consent Finalizes an authorization session with Heimdall. This is the final step carried out before the user agent will be redirected  to the client application. The accept consent operation allow you to specify which claims and scopes the user consented to.  Depending on your needs, you can also automatically accept claims without having asked the user for consent (this can be common  in some type of enterprise applications for instance). The accept consent also provides an opportunity to enriched the generated  token(s) with additional claims. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentAcceptRequest"></param>
        /// <returns>AuthResponse</returns>
        public AuthResponse ConsentAccept(ConsentAcceptRequest consentAcceptRequest)
        {
            heimdall_client.Client.ApiResponse<AuthResponse> localVarResponse = ConsentAcceptWithHttpInfo(consentAcceptRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept consent Finalizes an authorization session with Heimdall. This is the final step carried out before the user agent will be redirected  to the client application. The accept consent operation allow you to specify which claims and scopes the user consented to.  Depending on your needs, you can also automatically accept claims without having asked the user for consent (this can be common  in some type of enterprise applications for instance). The accept consent also provides an opportunity to enriched the generated  token(s) with additional claims. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentAcceptRequest"></param>
        /// <returns>ApiResponse of AuthResponse</returns>
        public heimdall_client.Client.ApiResponse<AuthResponse> ConsentAcceptWithHttpInfo(ConsentAcceptRequest consentAcceptRequest)
        {
            // verify the required parameter 'consentAcceptRequest' is set
            if (consentAcceptRequest == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'consentAcceptRequest' when calling AuthzApi->ConsentAccept");
            }

            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = consentAcceptRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<AuthResponse>("/authz/consent", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ConsentAccept", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Accept consent Finalizes an authorization session with Heimdall. This is the final step carried out before the user agent will be redirected  to the client application. The accept consent operation allow you to specify which claims and scopes the user consented to.  Depending on your needs, you can also automatically accept claims without having asked the user for consent (this can be common  in some type of enterprise applications for instance). The accept consent also provides an opportunity to enriched the generated  token(s) with additional claims. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentAcceptRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AuthResponse</returns>
        public async System.Threading.Tasks.Task<AuthResponse> ConsentAcceptAsync(ConsentAcceptRequest consentAcceptRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            heimdall_client.Client.ApiResponse<AuthResponse> localVarResponse = await ConsentAcceptWithHttpInfoAsync(consentAcceptRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept consent Finalizes an authorization session with Heimdall. This is the final step carried out before the user agent will be redirected  to the client application. The accept consent operation allow you to specify which claims and scopes the user consented to.  Depending on your needs, you can also automatically accept claims without having asked the user for consent (this can be common  in some type of enterprise applications for instance). The accept consent also provides an opportunity to enriched the generated  token(s) with additional claims. The operation will always return exactly one of the following JSON objects (all but one will have &#x60;null&#x60; values):  &#x60;auth&#x60;, &#x60;final_response&#x60;, &#x60;consent&#x60;, &#x60;error&#x60;.
        /// </summary>
        /// <exception cref="heimdall_client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentAcceptRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AuthResponse)</returns>
        public async System.Threading.Tasks.Task<heimdall_client.Client.ApiResponse<AuthResponse>> ConsentAcceptWithHttpInfoAsync(ConsentAcceptRequest consentAcceptRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'consentAcceptRequest' is set
            if (consentAcceptRequest == null)
            {
                throw new heimdall_client.Client.ApiException(400, "Missing required parameter 'consentAcceptRequest' when calling AuthzApi->ConsentAccept");
            }


            heimdall_client.Client.RequestOptions localVarRequestOptions = new heimdall_client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = heimdall_client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = heimdall_client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = consentAcceptRequest;

            // authentication (Bearer) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-KEY")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-KEY", this.Configuration.GetApiKeyWithPrefix("X-API-KEY"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<AuthResponse>("/authz/consent", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ConsentAccept", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
